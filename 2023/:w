#include "./utils.c"
#include <ctype.h>
#include <string.h>

void print_int_buff(const int* buff, const int len) {
  for(int i = 0; i < len; i++) {
    printf("%d, ", buff[i]);
  }
  printf("\n");
}

int solve_v1(int* buff, int len) {
  int checksum = 0;
  int dest_ptr = 1; // pointer to a free space to write memory to
  int read_ptr = 0; // pointer to the chunk we're reading from
  int mem_addr = buff[0]; // move the memory tracker straight to the first block 
  // of free space since the position id is 0
  
  // check if ending block is just free space
  if (len % 2 == 0) {
    len --;
  }

  printf("buffer = ");
  print_int_buff(buff, len);
  int max_iter = 100000;
  int iter = 0;
  for (read_ptr = len; read_ptr >= 0; read_ptr -=2) {
    printf("read ptr = %d\n", read_ptr);
    printf("dest ptr = %d\n", dest_ptr);
    
    // move on to the next item when there's no more memory in this chunk
    while(buff[read_ptr] > 0) {

      // move destination forward when there's no more free space
      if (buff[dest_ptr] == 0) {
        // also increment the memory pointer over existing memory 
        for (int y = 0; y < buff[dest_ptr+1]; y++) {
          checksum += (mem_addr * dest_ptr);
          mem_addr ++;
        }
        dest_ptr +=2;
      }
      
      // if dest meets read, then we're done moving chunks of memory
      if (dest_ptr >= read_ptr) {
        break;
      }
      buff[dest_ptr] --;
      buff[read_ptr] --;
      printf("moving a chunk in position %d to %d\n", read_ptr, dest_ptr);
      checksum += (mem_addr * (read_ptr/2));
      printf("buffer = ");
      print_int_buff(buff, len);
      printf("mem addr = %d\n", mem_addr);
      printf("checksum = %d\n", checksum);
      mem_addr ++;
      if (dest_ptr == read_ptr) {
        break;
      }
      if (iter > max_iter) {
        printf("max iter reached\n");
        break;
      }

      iter ++;
    }

  }

  // right now, we've computed the checksum for the built up continguous block 
  // of memory, however ther's still the memory that we weren't able to move
  // since none of this memory has been moved, the id should still correspond to 
  // dest_ptr
  printf("done looping. dest_ptr = %d\n", dest_ptr);
  while (dest_ptr <= len) {
    printf("dest ptr = %d\n", dest_ptr);
    for (int i = buff[dest_ptr]; i > 0; i--) {
      printf("buff[dest_ptr] = %d\n", buff[dest_ptr]);
      printf("mem addr = %d\n", mem_addr);
      checksum += (mem_addr * dest_ptr);
      mem_addr ++;
    } 

    dest_ptr += 2;
  }

  printf("checksum is %d\n", checksum);
  return checksum;
}
int main(int argc, char *argv[]) {
  if (argc != 3) {
    printf("usage: ./main input_file problem_section (1 or 2)\n");
    exit(1);
  }

  if (strnlen(argv[1], MAX_BUF_LENGTH) >= MAX_BUF_LENGTH) {
    printf("input exceeds max length of %d", MAX_BUF_LENGTH);
    exit(1);
  }

  FILE *fptr;

  printf("opening file %s\n", argv[1]);
  if ((fptr = fopen(argv[1], "r")) == NULL) {
    fprintf(stderr, "Error opening file\n");
    exit(1);
  }

  char mode_char = *argv[2];

  if (!isdigit(mode_char)) {
    fprintf(stderr, "second argument must be 1 or 2 \n");
    free(fptr);
    exit(1);
  }

  int mode = string_to_num(&mode_char);
  if ((mode != 1) && (mode != 2)) {
    fprintf(stderr, "second argument must be a 1 or 2");
    free(fptr);
    exit(1);
  }
  
  char* str_buff;
  ssize_t read;
  size_t len = 0;

  read = getline(&str_buff, &len, fptr);
  if (read == -1) {
    fprintf(stderr, "error reading file\n");
  }
  
  int string_len = 0;
  for (int i = 0; i < len; i++) {
    if (str_buff[i] != '\0') {
      string_len ++;
    } else {
      break;
    }
  }

  string_len --;

  int* buff = malloc(string_len * sizeof(int));
  for (int i = 0; i < string_len; i++) {
    buff[i] = (int) (str_buff[i] - 48);
  }
  if (mode == 1) {
    solve_v1(buff, string_len);
  }

  /*if (mode == 2) {*/
  /*  total = solve_v2(array);*/
  /*}*/
  /*printf("total is %d\n", total);*/
}

// 509 -> too high
// 338 -> too high
